# 基于 TCP 的服务器端/客户端

## 理解 TCP 和 UDP

根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP套接字 和 UDP 套接字。因为 TCP 是面向连接的，因此又称为 基于流（stream）的套接字。

TCP 是 Transmission Control Protocol （传输控制协议）的简写，意为“对数据传输过程的控制”。

### TCP/IP 协议栈

TCP/IP协议栈（Stack层）如图所示：

    应用层
  /        \
TCP层      UDP层
  \        /
     IP层
      |
    链路层

（数据通信中使用的协议栈分为 7 层，这里的 4 层对于理解TCP/IP协议就足够了）

### 链路层

链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义 LAN，WLAN，MAN 等网络标准。链路层负责物理连接的标准。

### IP层

准备好物理连接后，为了在复杂的网络中传输数据，首先需要考虑路径的选择。该层就是IP层，使用的协议就是IP。

IP本身是**面向消息**的，不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径；如果发生数据丢失或错误，则无法解决。换言之，IP协议无法对应数据错误。

### TCP/UDP层

IP层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP 和 UDP 以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称传输层。

IP层只关心一个数据包（数据传输的基本单位）的传输过程。因此，即使输入多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序和传输本身是不可靠的。

TCP 通过添加额外的对话方式，将不可靠的IP协议赋予可靠性。

### 应用层

编写软件的过程中，需要根据程序特点决定服务器端和客户端之间的数据传输规则（规定），这就是应用层协议。

## 实现基于 TCP/IP 的服务器端/客户端

### TCP服务器端的默认函数调用顺序

```c
socket() // 创建链接

bind() // 分配套接要地址

listen() // 等待连接请求状态

accept() // 允许连接

read(), write() // 数据交换

close() // 断开连接
```

### 进入等待连接请求状态

在已调用 bind函数 也套接字分配了地址后，接下来就要通过 listen函数 进入等待连接请求状态。只有调用了listen函数，客户端才能进入可超出连接请求的状态。换言之，客户端才能调用connect函数（若提前调用将发生错误）。

```c
#include <sys/socket.h>

int listen(int sock, int backlog);
// sock 希望进入等待连接请求状态的套接字文蛤描述符，传递的描述符套接字参数成为服务器端套接字（监听套接字）；
// backlog 连接请求等待队列（queue）的长度；（即，最多同时使多少个连接请求进入队列）
```

### 受理客户端连接请求

下面的函数将自动创建套接字，并连接到发起请求的客户端。

```c
#include <sys/socket.h>

int accept(int sock, struct sockaddr *addr, socklen_t * addrlen);
// sock 服务器套接字的文件描述符
// addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息
// addrlen 第二个参数addr结构体的长度，但是存有长度变量的地址。函数调用完成后，该参数即被填充入客户端地址的长度
```
